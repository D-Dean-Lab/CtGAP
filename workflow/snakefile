import sys
from pathlib import Path
from rich import print as pprint

import os

configfile: "config/config.yaml"
include: "rules/common.smk"

# inputs
INDIR = Path(config["indir"])
OUTDIR = Path(config["outdir"])
RESOURCES = Path(config["resourcesPath"])

#misc
MODE = config["mode"]
ORG = config["organism"]
REFSET = RESOURCES / "references" / ORG / "refset.fasta"
ADAPTERS = RESOURCES / "references" / ORG / "adapters.fasta"
BARCODES = RESOURCES / "references" / ORG / "barcodes.fasta"
SCAFFOLDREF = RESOURCES / "references" / ORG / "scaffold.fasta"
INDIVIDUAL = (RESOURCES / "references" / ORG / "individual").glob("*")
INDIVIDUAL_DICT = {n.stem:str(n.resolve()) for n in INDIVIDUAL}

# references
HOSTREF = Path(config["hostReference"])

# databases
KRAKENDB = Path(config["krakenDB"])
OMPABLASTDB = Path(config["ompaBlastDB"])
MLSTDB = Path(config["mlstDB"])

# reference configuration
if config["reference"] == "plurality":
        REF = RESOURCES / "references" / ORG / "plurality.fasta"
elif config["reference"] == "reference_set":
        REF = RESOURCES / "references" / ORG / "refset.fasta"
else:
        REF = RESOURCES / "references" / ORG / f"{config['reference']}"

# get samples
ENVONLY = (os.environ.get("CTGAP_ENVONLY") == "1") or (str(config.get("envonly", "0")) == "1")

if ENVONLY:
    # Dummy sample lets Snakemake build the DAG and create envs without real inputs
    SAMPLES = {"DUMMY"}
else:
    SAMPLE_NAME, PAIR = glob_wildcards(INDIR / "{sample_name}_R{pair}.fastq.gz")
    SAMPLES = set(SAMPLE_NAME)
    if not SAMPLES:
        print("[yellow] No samples were detected. Check the 'indir' in config.yaml and ensure it matches your FASTQ pattern.")
        sys.exit(1)

# CT typing outputs (conditional on config)
if config.get("ct_typing", {}).get("enabled", False):
    ct_typing_input_list = [
        # Per-sample status files
        expand(OUTDIR / "status" / "ct_typing.{sample}.txt", sample=SAMPLES),
        # Combined summary report
        OUTDIR / "reports" / "ct_typing_all_samples.csv",
        OUTDIR / "status" / "ct_typing.summary.txt",
    ]
else:
    ct_typing_input_list = []

# Annotation outputs (conditional on config)
# Uses checkpoint to dynamically determine which samples get annotated
if config.get("annotation", {}).get("enabled", True):
    annotation_input_list = [
        OUTDIR / "status" / "annotation.complete.txt",
    ]
else:
    annotation_input_list = []

# Mixed strain detection outputs (conditional on config)
if config.get("mixed_detection", {}).get("enabled", True):
    mixed_detection_input_list = [
        OUTDIR / "status" / "mixed_detection.complete.txt",
    ]
else:
    mixed_detection_input_list = []

# Assembly filtering outputs (conditional on config)
if config.get("assembly_filter", {}).get("enabled", True):
    assembly_filter_input_list = [
        expand(OUTDIR / "status" / "filter_applied.{sample}.txt", sample=SAMPLES),
        OUTDIR / "reports" / "assembly_filter_summary.tsv",
    ]
else:
    assembly_filter_input_list = [
        expand(OUTDIR / "status" / "filter_applied.{sample}.txt", sample=SAMPLES),  # dummy status
    ]

# Choose inputs based on mode
if ENVONLY:
    # During setup, only request minimal outputs to build conda envs
    input_list = [
        OUTDIR / "status" / "setup_complete.txt"
    ]
    
    # Simple dummy rule for environment setup
    rule setup_envs:
        output:
            OUTDIR / "status" / "setup_complete.txt"
        shell:
            """
            mkdir -p {OUTDIR}/status
            echo "Conda environments created successfully" > {output}
            echo "Run 'ctgap run' to start analysis" >> {output}
            """

elif config["mode"] == "denovo":
    input_list = [
        # Assembly selection metadata
        expand(OUTDIR / "reports" / "assembly_selection" / "{sample}.method.txt", sample=SAMPLES),
        OUTDIR / "reports" / "assembly_methods_summary.txt",
        # Typing outputs (run on best assembly)
        expand(OUTDIR / "status" / "best.blastn.{sample}.txt", sample=SAMPLES),
        OUTDIR / "status" / "best.ompA_genovar.collate.blast.txt",
        OUTDIR / "status" / "best.secondary.collate.blast.txt",
        expand(OUTDIR / "status" / "best.mlst.{sample}.txt", sample=SAMPLES),
        OUTDIR / "status" / "best.mlst.collate.txt",
        OUTDIR / f"{ORG}.tree",
        # Coverage
        OUTDIR / "denovo.coverage.tsv",
        # Alignment statistics
        OUTDIR / "reports" / "denovo.alignment_summary.txt",
        # Dedicated plasmid assembly (reference-guided + Unicycler)
        expand(OUTDIR / "{sample}" / "plasmid" / "{sample}.plasmid.fasta", sample=SAMPLES),
        expand(OUTDIR / "{sample}" / "reports" / "{sample}_plasmid_report.pdf", sample=SAMPLES),
        OUTDIR / "status" / "plasmid.collate.txt",
        OUTDIR / "reports" / "plasmid_summary.tsv",
        OUTDIR / "reports" / "plasmid_analysis_report.txt",
        # Summary reports
        OUTDIR / "reports" / "scaffold_summary.txt",
        # Comprehensive reports
        expand(OUTDIR / "{sample}" / "reports" / "{sample}_ctgap_report.pdf", sample=SAMPLES),
        OUTDIR / "reports" / "ctgap_all_samples_summary.csv",
        OUTDIR / "reports" / "ctgap_batch_summary.txt",
        # Final reorganization
        OUTDIR / "status" / "reorganize_complete.txt",
    ] + ct_typing_input_list + annotation_input_list + mixed_detection_input_list + assembly_filter_input_list

elif config["mode"] == "reference-denovo":
    input_list = [
        # Assembly selection metadata
        expand(OUTDIR / "reports" / "assembly_selection" / "{sample}.method.txt", sample=SAMPLES),
        OUTDIR / "reports" / "assembly_methods_summary.txt",
        # Typing outputs (run on best assembly)
        expand(OUTDIR / "status" / "best.blastn.{sample}.txt", sample=SAMPLES),
        OUTDIR / "status" / "best.ompA_genovar.collate.blast.txt",
        OUTDIR / "status" / "best.secondary.collate.blast.txt",
        expand(OUTDIR / "status" / "best.mlst.{sample}.txt", sample=SAMPLES),
        OUTDIR / "status" / "best.mlst.collate.txt",
        OUTDIR / f"{ORG}.tree",
        # Coverage
        OUTDIR / "ref-denovo.coverage.tsv",
        # Alignment statistics
        OUTDIR / "reports" / "ref-denovo.alignment_summary.txt",
        # QUAST vs reference
        expand(OUTDIR / "status" / "ref-denovo.assembly_statistics_vs_scaffold.{sample}.txt", sample=SAMPLES),
        # Dedicated plasmid assembly (reference-guided + Unicycler)
        expand(OUTDIR / "{sample}" / "plasmid" / "{sample}.plasmid.fasta", sample=SAMPLES),
        expand(OUTDIR / "{sample}" / "reports" / "{sample}_plasmid_report.pdf", sample=SAMPLES),
        OUTDIR / "status" / "plasmid.collate.txt",
        OUTDIR / "reports" / "plasmid_summary.tsv",
        OUTDIR / "reports" / "plasmid_analysis_report.txt",
        # Summary reports
        OUTDIR / "reports" / "ref_scaffold_summary.txt",
        # Comprehensive reports
        expand(OUTDIR / "{sample}" / "reports" / "{sample}_ctgap_report.pdf", sample=SAMPLES),
        OUTDIR / "reports" / "ctgap_all_samples_summary.csv",
        OUTDIR / "reports" / "ctgap_batch_summary.txt",
        # Final reorganization
        OUTDIR / "status" / "reorganize_complete.txt",
    ] + ct_typing_input_list + annotation_input_list + mixed_detection_input_list + assembly_filter_input_list

elif config["mode"] == "auto":
    input_list = [
        # Assembly selection
        expand(OUTDIR / "reports" / "assembly_selection" / "{sample}.txt", sample=SAMPLES),
        OUTDIR / "reports" / "assembly_methods_summary.txt",
        # Typing outputs (run ONCE on best assembly)
        expand(OUTDIR / "status" / "best.blastn.{sample}.txt", sample=SAMPLES),
        OUTDIR / "status" / "best.ompA_genovar.collate.blast.txt",
        OUTDIR / "status" / "best.secondary.collate.blast.txt",
        expand(OUTDIR / "status" / "best.mlst.{sample}.txt", sample=SAMPLES),
        OUTDIR / "status" / "best.mlst.collate.txt",
        OUTDIR / f"{ORG}.tree",
        # Coverage (both modes)
        OUTDIR / "denovo.coverage.tsv",
        OUTDIR / "ref-denovo.coverage.tsv",
        # Alignment statistics (both modes)
        OUTDIR / "reports" / "denovo.alignment_summary.txt",
        OUTDIR / "reports" / "ref-denovo.alignment_summary.txt",
        # QUAST vs reference (ref-denovo assemblies)
        expand(OUTDIR / "status" / "ref-denovo.assembly_statistics_vs_scaffold.{sample}.txt", sample=SAMPLES),
        # Dedicated plasmid assembly (reference-guided + Unicycler)
        expand(OUTDIR / "{sample}" / "plasmid" / "{sample}.plasmid.fasta", sample=SAMPLES),
        expand(OUTDIR / "{sample}" / "reports" / "{sample}_plasmid_report.pdf", sample=SAMPLES),
        OUTDIR / "status" / "plasmid.collate.txt",
        OUTDIR / "reports" / "plasmid_summary.tsv",
        OUTDIR / "reports" / "plasmid_analysis_report.txt",
        # Summary reports
        OUTDIR / "reports" / "scaffold_summary.txt",
        OUTDIR / "reports" / "ref_scaffold_summary.txt",
        # Comprehensive reports
        expand(OUTDIR / "{sample}" / "reports" / "{sample}_ctgap_report.pdf", sample=SAMPLES),
        OUTDIR / "reports" / "ctgap_all_samples_summary.csv",
        OUTDIR / "reports" / "ctgap_batch_summary.txt",
        # Final reorganization
        OUTDIR / "status" / "reorganize_complete.txt",
    ] + ct_typing_input_list + annotation_input_list + mixed_detection_input_list + assembly_filter_input_list

else:
    raise ValueError(f"{config['mode']} is an invalid mode. Choose: 'denovo', 'reference-denovo', 'auto'.")

rule all:
    input:
        input_list

# Common modules
include: "rules/1-trim.smk"
include: "rules/2-scrub_hocort.smk"
include: "rules/3-qc.smk"

# Assembly modules - always include, mode controls which rules activate
include: "rules/4-assemble.smk"     # Provides de novo assembly
include: "rules/5-align.smk"        # Provides reference-guided assembly
include: "rules/6-select-best.smk"  # Handles selection logic for all modes
include: "rules/6b-filter-contigs.smk"  # Post-assembly filtering (removes non-Ct contigs)
include: "rules/7-typing.smk"       # Typing (works on "best" assembly)

# Dedicated plasmid module - reference-guided assembly for CT plasmid
# Uses read mapping to reference plasmid + Unicycler for clean plasmid assembly
if not ENVONLY:
    include: "rules/plasmid_dedicated.smk"

# CT typing (optional, works with any assembly mode)
if config.get("ct_typing", {}).get("enabled", False) and not ENVONLY:
    include: "rules/6-ct_typing.smk"

# Genome annotation (optional, checkpoint-based for samples with sufficient coverage)
if config.get("annotation", {}).get("enabled", True) and not ENVONLY:
    include: "rules/10-annotate.smk"

# Mixed strain detection (variant heterozygosity analysis)
if config.get("mixed_detection", {}).get("enabled", True) and not ENVONLY:
    include: "rules/11-mixed-detection.smk"

# Comprehensive reporting (combines chromosome and plasmid analysis)
if not ENVONLY:
    include: "rules/8-reports.smk"

# Final output reorganization (creates clean user-facing structure)
if not ENVONLY:
    include: "rules/9-reorganize.smk"
