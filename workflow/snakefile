import sys
from pathlib import Path
from rich import print as pprint

import os

configfile: "config/config.yaml"
include: "rules/common.smk"

# inputs
INDIR = Path(config["indir"])
OUTDIR = Path(config["outdir"])
RESOURCES = Path(config["resourcesPath"])

#misc
MODE = config["mode"]
ORG = config["organism"]
REFSET = RESOURCES / "references" / ORG / "refset.fasta"
ADAPTERS = RESOURCES / "references" / ORG / "adapters.fasta"
BARCODES = RESOURCES / "references" / ORG / "barcodes.fasta"
SCAFFOLDREF = RESOURCES / "references" / ORG / "scaffold.fasta"
INDIVIDUAL = (RESOURCES / "references" / ORG / "individual").glob("*")
INDIVIDUAL_DICT = {n.stem:str(n.resolve()) for n in INDIVIDUAL}

# references
HOSTREF = Path(config["hostReference"])

# databases
KRAKENDB = Path(config["krakenDB"])
OMPABLASTDB = Path(config["ompaBlastDB"])
MLSTDB = Path(config["mlstDB"])

# reference configuration
if config["reference"] == "plurality":
        REF = RESOURCES / "references" / ORG / "plurality.fasta"
elif config["reference"] == "reference_set":
        REF = RESOURCES / "references" / ORG / "refset.fasta"
else:
        REF = RESOURCES / "references" / ORG / f"{config['reference']}"

# get samples
ENVONLY = (os.environ.get("CTGAP_ENVONLY") == "1") or (str(config.get("envonly", "0")) == "1")

if ENVONLY:
    # Dummy sample lets Snakemake build the DAG and create envs without real inputs
    SAMPLES = {"DUMMY"}
else:
    SAMPLE_NAME, PAIR = glob_wildcards(INDIR / "{sample_name}_R{pair}.fastq.gz")
    SAMPLES = set(SAMPLE_NAME)
    if not SAMPLES:
        print("[yellow] No samples were detected. Check the 'indir' in config.yaml and ensure it matches your FASTQ pattern.")
        sys.exit(1)

# CT typing outputs (conditional on config)
if config.get("ct_typing", {}).get("enabled", False):
    ct_typing_input_list = [
        # Per-sample status files
        expand(OUTDIR / "status" / "ct_typing.{sample}.txt", sample=SAMPLES),
        # Combined summary report
        OUTDIR / "reports" / "ct_typing_all_samples.csv",
        OUTDIR / "status" / "ct_typing.summary.txt",
    ]
else:
    ct_typing_input_list = []

# Choose inputs based on mode
if ENVONLY:
    # During setup, only request minimal outputs to build conda envs
    input_list = [
        OUTDIR / "status" / "setup_complete.txt"
    ]
    
    # Simple dummy rule for environment setup
    rule setup_envs:
        output:
            OUTDIR / "status" / "setup_complete.txt"
        shell:
            """
            mkdir -p {OUTDIR}/status
            echo "Conda environments created successfully" > {output}
            echo "Run 'ctgap run' to start analysis" >> {output}
            """

elif config["mode"] == "denovo":
    input_list = [
        # Assembly selection metadata
        expand(OUTDIR / "reports" / "assembly_selection" / "{sample}.method.txt", sample=SAMPLES),
        OUTDIR / "reports" / "assembly_methods_summary.txt",
        # Typing outputs (run on best assembly)
        expand(OUTDIR / "status" / "best.blastn.{sample}.txt", sample=SAMPLES),
        OUTDIR / "status" / "best.ompA_genovar.collate.blast.txt",
        OUTDIR / "status" / "best.secondary.collate.blast.txt",
        expand(OUTDIR / "status" / "best.mlst.{sample}.txt", sample=SAMPLES),
        OUTDIR / "status" / "best.mlst.collate.txt",
        OUTDIR / f"{ORG}.tree",
        # Coverage
        OUTDIR / "denovo.coverage.tsv",
        # Plasmid outputs (Unicycler-based)
        expand(OUTDIR / "{sample}" / "denovo" / "unicycler" / "plasmids_only.fasta", sample=SAMPLES),
        expand(OUTDIR / "{sample}" / "reports" / "{sample}_plasmid_report.pdf", sample=SAMPLES),
        OUTDIR / "status" / "denovo.plasmid.collate.blast.txt",
        OUTDIR / "status" / "denovo.mlst.plasmid.collate.txt",
        OUTDIR / "reports" / "comprehensive_plasmid_analysis.txt",
        # Summary reports
        OUTDIR / "reports" / "scaffold_summary.txt",
    ] + ct_typing_input_list

elif config["mode"] == "reference-denovo":
    input_list = [
        # Assembly selection metadata
        expand(OUTDIR / "reports" / "assembly_selection" / "{sample}.method.txt", sample=SAMPLES),
        OUTDIR / "reports" / "assembly_methods_summary.txt",
        # Typing outputs (run on best assembly)
        expand(OUTDIR / "status" / "best.blastn.{sample}.txt", sample=SAMPLES),
        OUTDIR / "status" / "best.ompA_genovar.collate.blast.txt",
        OUTDIR / "status" / "best.secondary.collate.blast.txt",
        expand(OUTDIR / "status" / "best.mlst.{sample}.txt", sample=SAMPLES),
        OUTDIR / "status" / "best.mlst.collate.txt",
        OUTDIR / f"{ORG}.tree",
        # Ref-specific
        OUTDIR / "status" / "ref-denovo.collate.coverage.txt",
        OUTDIR / "reports" / "ref-denovo.alignment_summary.txt",
        OUTDIR / "reports" / "ref_scaffold_summary.txt",
    ] + ct_typing_input_list

elif config["mode"] == "auto":
    input_list = [
        # Assembly selection
        expand(OUTDIR / "reports" / "assembly_selection" / "{sample}.txt", sample=SAMPLES),
        OUTDIR / "reports" / "assembly_methods_summary.txt",
        # Typing outputs (run ONCE on best assembly)
        expand(OUTDIR / "status" / "best.blastn.{sample}.txt", sample=SAMPLES),
        OUTDIR / "status" / "best.ompA_genovar.collate.blast.txt",
        OUTDIR / "status" / "best.secondary.collate.blast.txt",
        expand(OUTDIR / "status" / "best.mlst.{sample}.txt", sample=SAMPLES),
        OUTDIR / "status" / "best.mlst.collate.txt",
        OUTDIR / f"{ORG}.tree",
        # Plasmid outputs (Unicycler-based)
        expand(OUTDIR / "{sample}" / "denovo" / "unicycler" / "plasmids_only.fasta", sample=SAMPLES),
        expand(OUTDIR / "{sample}" / "reports" / "{sample}_plasmid_report.pdf", sample=SAMPLES),
        OUTDIR / "status" / "denovo.plasmid.collate.blast.txt",
        OUTDIR / "status" / "denovo.mlst.plasmid.collate.txt",
        OUTDIR / "reports" / "comprehensive_plasmid_analysis.txt",
        # Summary reports
        OUTDIR / "reports" / "scaffold_summary.txt",
        OUTDIR / "reports" / "ref_scaffold_summary.txt",
    ] + ct_typing_input_list

else:
    raise ValueError(f"{config['mode']} is an invalid mode. Choose: 'denovo', 'reference-denovo', 'auto'.")

rule all:
    input:
        input_list

# Common modules
include: "rules/1-trim.smk"
include: "rules/2-scrub_hocort.smk"
include: "rules/3-qc.smk"

# Assembly modules - always include, mode controls which rules activate
include: "rules/4-assemble.smk"     # Provides de novo assembly
include: "rules/5-align.smk"        # Provides reference-guided assembly
include: "rules/6-select-best.smk"  # Handles selection logic for all modes
include: "rules/7-typing.smk"       # Typing (works on "best" assembly)

# Detailed plasmid module (denovo/auto only)
if config["mode"] in ["denovo", "auto"] and not ENVONLY:
    include: "rules/plasmid.smk"

# CT typing (optional, works with any assembly mode)
if config.get("ct_typing", {}).get("enabled", False) and not ENVONLY:
    include: "rules/6-ct_typing.smk"
